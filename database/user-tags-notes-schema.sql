-- Additional schema for user-created tags and multiple notes
-- This extends the existing schema to support our UI requirements
-- Run this script in your Supabase SQL Editor after the main schema

-- =====================================================
-- USER-CREATED TAGS AND NOTES TABLES
-- =====================================================

-- User-created tags (different from admin-curated tags)
-- Users can create their own custom tags for movies
DROP TABLE IF EXISTS public.user_tags CASCADE;
CREATE TABLE IF NOT EXISTS public.user_tags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
  tag_name TEXT NOT NULL CHECK (char_length(tag_name) <= 50),
  color TEXT DEFAULT '#3B82F6', -- Default blue color
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  -- Ensure user can't create duplicate tags for the same movie
  UNIQUE(user_id, movie_id, tag_name)
);

-- User notes (multiple notes per movie per user)
-- Users can add multiple notes/thoughts about a movie
DROP TABLE IF EXISTS public.user_notes CASCADE;
CREATE TABLE IF NOT EXISTS public.user_notes (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
  content TEXT NOT NULL CHECK (char_length(content) <= 1000),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================

-- User tags indexes
CREATE INDEX IF NOT EXISTS idx_user_tags_user_id ON public.user_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_user_tags_movie_id ON public.user_tags(movie_id);
CREATE INDEX IF NOT EXISTS idx_user_tags_user_movie ON public.user_tags(user_id, movie_id);

-- User notes indexes
CREATE INDEX IF NOT EXISTS idx_user_notes_user_id ON public.user_notes(user_id);
CREATE INDEX IF NOT EXISTS idx_user_notes_movie_id ON public.user_notes(movie_id);
CREATE INDEX IF NOT EXISTS idx_user_notes_user_movie ON public.user_notes(user_id, movie_id);
CREATE INDEX IF NOT EXISTS idx_user_notes_created_at ON public.user_notes(created_at);

-- =====================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================

-- Enable RLS on new tables
ALTER TABLE public.user_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_notes ENABLE ROW LEVEL SECURITY;

-- User can only access their own tags
CREATE POLICY "user_tags_self_access" ON public.user_tags
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- User can only access their own notes
CREATE POLICY "user_notes_self_access" ON public.user_notes
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- =====================================================
-- TRIGGERS FOR UPDATED_AT
-- =====================================================

-- Trigger for user_notes updated_at
CREATE TRIGGER update_user_notes_updated_at
    BEFORE UPDATE ON public.user_notes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- HELPER FUNCTIONS
-- =====================================================

-- Function to get user's tags for a specific movie
CREATE OR REPLACE FUNCTION get_user_movie_tags(user_uuid UUID, movie_bigint BIGINT)
RETURNS TABLE (
  id BIGINT,
  tag_name TEXT,
  color TEXT,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    ut.id,
    ut.tag_name,
    ut.color,
    ut.created_at
  FROM public.user_tags ut
  WHERE ut.user_id = user_uuid AND ut.movie_id = movie_bigint
  ORDER BY ut.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get user's notes for a specific movie
CREATE OR REPLACE FUNCTION get_user_movie_notes(user_uuid UUID, movie_bigint BIGINT)
RETURNS TABLE (
  id BIGINT,
  content TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    un.id,
    un.content,
    un.created_at,
    un.updated_at
  FROM public.user_notes un
  WHERE un.user_id = user_uuid AND un.movie_id = movie_bigint
  ORDER BY un.created_at DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
