-- CineFind Database Schema
-- Run this script in your Supabase SQL Editor

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- =====================================================
-- CORE TABLES
-- =====================================================

-- Core movie catalog
DROP TABLE IF EXISTS public.movies CASCADE;
CREATE TABLE IF NOT EXISTS public.movies (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT,
  release_date DATE,
  poster_url TEXT,
  genre TEXT,
  director TEXT,
  runtime_minutes INTEGER,
  imdb_id TEXT,
  tmdb_id INTEGER,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Admin-curated tags
DROP TABLE IF EXISTS public.tags CASCADE;
CREATE TABLE IF NOT EXISTS public.tags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  color TEXT DEFAULT '#6B7280', -- For UI customization
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Admin-curated categories
DROP TABLE IF EXISTS public.categories CASCADE;
CREATE TABLE IF NOT EXISTS public.categories (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  description TEXT,
  color TEXT DEFAULT '#6B7280', -- For UI customization
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- User profiles (extends auth.users)
DROP TABLE IF EXISTS public.profiles CASCADE;
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  display_name TEXT NOT NULL,
  email TEXT UNIQUE, -- cached for quick lookup (optional)
  avatar_url TEXT,
  bio TEXT CHECK (char_length(bio) <= 500),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- =====================================================
-- USER PERSONALIZATION TABLES
-- =====================================================

-- User-specific movie tagging (many-to-many)
DROP TABLE IF EXISTS public.user_movie_tags CASCADE;
CREATE TABLE IF NOT EXISTS public.user_movie_tags (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
  tag_id BIGINT NOT NULL REFERENCES public.tags(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (user_id, movie_id, tag_id)
);

-- User-specific movie categorization (one category per movie per user)
DROP TABLE IF EXISTS public.user_movie_categories CASCADE;
CREATE TABLE IF NOT EXISTS public.user_movie_categories (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
  category_id BIGINT NOT NULL REFERENCES public.categories(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (user_id, movie_id)
);

-- User-specific movie notes
DROP TABLE IF EXISTS public.user_movie_notes CASCADE;
CREATE TABLE IF NOT EXISTS public.user_movie_notes (
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  movie_id BIGINT NOT NULL REFERENCES public.movies(id) ON DELETE CASCADE,
  note TEXT CHECK (char_length(note) <= 400),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  PRIMARY KEY (user_id, movie_id)
);

-- =====================================================
-- INDEXES FOR PERFORMANCE
-- =====================================================

-- Movies table indexes
CREATE INDEX IF NOT EXISTS idx_movies_title ON public.movies USING GIN (to_tsvector('english', title));
CREATE INDEX IF NOT EXISTS idx_movies_genre ON public.movies(genre);
CREATE INDEX IF NOT EXISTS idx_movies_release_date ON public.movies(release_date);
CREATE INDEX IF NOT EXISTS idx_movies_created_at ON public.movies(created_at);

-- User personalization indexes
CREATE INDEX IF NOT EXISTS idx_user_movie_tags_user_id ON public.user_movie_tags(user_id);
CREATE INDEX IF NOT EXISTS idx_user_movie_tags_movie_id ON public.user_movie_tags(movie_id);
CREATE INDEX IF NOT EXISTS idx_user_movie_categories_user_id ON public.user_movie_categories(user_id);
CREATE INDEX IF NOT EXISTS idx_user_movie_categories_movie_id ON public.user_movie_categories(movie_id);
CREATE INDEX IF NOT EXISTS idx_user_movie_notes_user_id ON public.user_movie_notes(user_id);

-- =====================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- =====================================================

-- Enable RLS on user-specific tables
ALTER TABLE public.user_movie_tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_movie_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_movie_notes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- User can only access their own tags
CREATE POLICY "user_tags_self_access" ON public.user_movie_tags
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- User can only access their own categories
CREATE POLICY "user_categories_self_access" ON public.user_movie_categories
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- User can only access their own notes
CREATE POLICY "user_notes_self_access" ON public.user_movie_notes
  FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);

-- User can only access their own profile
CREATE POLICY "users_can_view_own_profile" ON public.profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "users_can_update_own_profile" ON public.profiles
  FOR UPDATE USING (auth.uid() = id);

-- Allow users to insert their own profile
CREATE POLICY "users_can_insert_own_profile" ON public.profiles
  FOR INSERT WITH CHECK (auth.uid() = id);

-- =====================================================
-- PUBLIC READ ACCESS FOR CORE DATA
-- =====================================================

-- Allow public read access to movies, tags, and categories
ALTER TABLE public.movies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.tags ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;

-- Everyone can read movies
CREATE POLICY "movies_public_read" ON public.movies
  FOR SELECT USING (true);

-- Everyone can read tags
CREATE POLICY "tags_public_read" ON public.tags
  FOR SELECT USING (true);

-- Everyone can read categories
CREATE POLICY "categories_public_read" ON public.categories
  FOR SELECT USING (true);

-- =====================================================
-- FUNCTIONS AND TRIGGERS
-- =====================================================

-- Function to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers for updated_at
CREATE TRIGGER update_movies_updated_at
    BEFORE UPDATE ON public.movies
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_user_movie_notes_updated_at
    BEFORE UPDATE ON public.user_movie_notes
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();

-- Function to create user profile on signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, display_name, email)
  VALUES (
    NEW.id, 
    COALESCE(NEW.raw_user_meta_data->>'display_name', 'User'),
    NEW.email
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to automatically create profile when user signs up
CREATE OR REPLACE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- =====================================================
-- HELPER FUNCTIONS
-- =====================================================

-- Function to search movies with full-text search
CREATE OR REPLACE FUNCTION search_movies(search_term TEXT)
RETURNS TABLE (
  id BIGINT,
  title TEXT,
  description TEXT,
  release_date DATE,
  poster_url TEXT,
  genre TEXT,
  director TEXT,
  runtime_minutes INTEGER,
  created_at TIMESTAMPTZ,
  rank REAL
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    m.id,
    m.title,
    m.description,
    m.release_date,
    m.poster_url,
    m.genre,
    m.director,
    m.runtime_minutes,
    m.created_at,
    ts_rank(to_tsvector('english', m.title || ' ' || COALESCE(m.description, '')), plainto_tsquery('english', search_term)) as rank
  FROM public.movies m
  WHERE to_tsvector('english', m.title || ' ' || COALESCE(m.description, '')) @@ plainto_tsquery('english', search_term)
  ORDER BY rank DESC, m.title;
END;
$$ LANGUAGE plpgsql;

-- Function to get user's personalized movie data
CREATE OR REPLACE FUNCTION get_user_movie_data(user_uuid UUID, movie_bigint BIGINT)
RETURNS TABLE (
  movie_id BIGINT,
  user_tags TEXT[],
  user_category TEXT,
  user_note TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    movie_bigint as movie_id,
    COALESCE(
      (SELECT ARRAY_AGG(t.name) 
       FROM public.user_movie_tags umt 
       JOIN public.tags t ON umt.tag_id = t.id 
       WHERE umt.user_id = user_uuid AND umt.movie_id = movie_bigint), 
      '{}'::TEXT[]
    ) as user_tags,
    (SELECT c.name 
     FROM public.user_movie_categories umc 
     JOIN public.categories c ON umc.category_id = c.id 
     WHERE umc.user_id = user_uuid AND umc.movie_id = movie_bigint) as user_category,
    (SELECT umn.note 
     FROM public.user_movie_notes umn 
     WHERE umn.user_id = user_uuid AND umn.movie_id = movie_bigint) as user_note;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
